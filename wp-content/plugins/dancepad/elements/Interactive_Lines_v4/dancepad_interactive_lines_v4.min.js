class InteractiveLinesV4{static instances=[];constructor(container){this.container=container;this.canvas=container.querySelector(".dan-interactive-lines-v4__canvas");this.ctx=this.canvas.getContext("2d");this.lines=[];const style=getComputedStyle(container);const attr=container.getAttribute.bind(container);this.config={lineColor:style.getPropertyValue('--line-color').trim(),waveSpeedX:parseFloat(attr("data-wave-speed-x")),waveSpeedY:parseFloat(attr("data-wave-speed-y")),waveAmpX:parseFloat(attr("data-wave-amp-x")),waveAmpY:parseFloat(attr("data-wave-amp-y")),xGap:parseFloat(attr("data-x-gap")),yGap:parseFloat(attr("data-y-gap")),friction:parseFloat(attr("data-friction")),tension:parseFloat(attr("data-tension")),maxCursorMove:parseFloat(attr("data-max-cursor-move")),};this.mouse={x:-10,y:0,lx:0,ly:0,sx:0,sy:0,v:0,vs:0,a:0,set:!1};this.noise=new InteractiveLinesV4.Noise(Math.random());this.resizeHandler=this.resize.bind(this);this.mouseHandler=this.onMouseMove.bind(this);this.touchHandler=this.onTouchMove.bind(this);window.addEventListener('resize',this.resizeHandler);this.container.addEventListener("mousemove",this.mouseHandler);this.container.addEventListener("touchmove",this.touchHandler,{passive:!1});this.resize();this.animate(0)}
resize(){this.canvas.width=this.container.clientWidth;this.canvas.height=this.container.clientHeight;this.setLines()}
setLines(){this.lines=[];const{xGap,yGap}=this.config;const totalLines=Math.ceil((this.canvas.width+200)/xGap);const totalPoints=Math.ceil((this.canvas.height+30)/yGap);const xStart=(this.canvas.width-xGap*totalLines)/2;const yStart=(this.canvas.height-yGap*totalPoints)/2;for(let i=0;i<=totalLines;i++){const pts=[];for(let j=0;j<=totalPoints;j++){pts.push({x:xStart+xGap*i,y:yStart+yGap*j,wave:{x:0,y:0},cursor:{x:0,y:0,vx:0,vy:0}})}
this.lines.push(pts)}}
onMouseMove(e){const rect=this.canvas.getBoundingClientRect();this.updateMouse(e.clientX-rect.left,e.clientY-rect.top)}
onTouchMove(e){const touch=e.touches[0];const rect=this.canvas.getBoundingClientRect();this.updateMouse(touch.clientX-rect.left,touch.clientY-rect.top);e.preventDefault()}
updateMouse(x,y){this.mouse.x=x;this.mouse.y=y;if(!this.mouse.set){this.mouse.sx=x;this.mouse.sy=y;this.mouse.lx=x;this.mouse.ly=y;this.mouse.set=!0}}
movePoints(time){const{waveSpeedX,waveSpeedY,waveAmpX,waveAmpY,tension,friction,maxCursorMove}=this.config;for(const pts of this.lines){for(const p of pts){const move=this.noise.perlin2((p.x+time*waveSpeedX)*0.002,(p.y+time*waveSpeedY)*0.0015)*12;p.wave.x=Math.cos(move)*waveAmpX;p.wave.y=Math.sin(move)*waveAmpY;const dx=p.x-this.mouse.sx;const dy=p.y-this.mouse.sy;const dist=Math.hypot(dx,dy);const l=Math.max(175,this.mouse.vs);if(dist<l){const s=1-dist/l;const f=Math.cos(dist*0.001)*s;p.cursor.vx+=Math.cos(this.mouse.a)*f*l*this.mouse.vs*0.00065;p.cursor.vy+=Math.sin(this.mouse.a)*f*l*this.mouse.vs*0.00065}
p.cursor.vx+=(0-p.cursor.x)*tension;p.cursor.vy+=(0-p.cursor.y)*tension;p.cursor.vx*=friction;p.cursor.vy*=friction;p.cursor.x+=p.cursor.vx*2;p.cursor.y+=p.cursor.vy*2;p.cursor.x=Math.max(-maxCursorMove,Math.min(maxCursorMove,p.cursor.x));p.cursor.y=Math.max(-maxCursorMove,Math.min(maxCursorMove,p.cursor.y))}}}
drawLines(){const ctx=this.ctx;ctx.clearRect(0,0,this.canvas.width,this.canvas.height);ctx.beginPath();ctx.strokeStyle=this.config.lineColor;for(const points of this.lines){const p1=this.getMoved(points[0],!1);ctx.moveTo(p1.x,p1.y);for(const p of points){const p2=this.getMoved(p,!0);ctx.lineTo(p2.x,p2.y)}}
ctx.stroke()}
getMoved(p,withCursor=!0){return{x:Math.round((p.x+p.wave.x+(withCursor?p.cursor.x:0))*10)/10,y:Math.round((p.y+p.wave.y+(withCursor?p.cursor.y:0))*10)/10,}}
animate=(time)=>{this.mouse.sx+=(this.mouse.x-this.mouse.sx)*0.1;this.mouse.sy+=(this.mouse.y-this.mouse.sy)*0.1;const dx=this.mouse.x-this.mouse.lx;const dy=this.mouse.y-this.mouse.ly;const d=Math.hypot(dx,dy);this.mouse.v=d;this.mouse.vs+=(d-this.mouse.vs)*0.1;this.mouse.vs=Math.min(100,this.mouse.vs);this.mouse.lx=this.mouse.x;this.mouse.ly=this.mouse.y;this.mouse.a=Math.atan2(dy,dx);this.movePoints(time);this.drawLines();this.animationFrame=requestAnimationFrame(this.animate)}
destroy(){cancelAnimationFrame(this.animationFrame);window.removeEventListener("resize",this.resizeHandler);this.container.removeEventListener("mousemove",this.mouseHandler);this.container.removeEventListener("touchmove",this.touchHandler);this.ctx.clearRect(0,0,this.canvas.width,this.canvas.height)}
static destroyAllInstances(){InteractiveLinesV4.instances.forEach(instance=>instance.destroy());InteractiveLinesV4.instances=[]}}
InteractiveLinesV4.Noise=class{constructor(seed=0){this.grad3=[new Grad(1,1,0),new Grad(-1,1,0),new Grad(1,-1,0),new Grad(-1,-1,0),new Grad(1,0,1),new Grad(-1,0,1),new Grad(1,0,-1),new Grad(-1,0,-1),new Grad(0,1,1),new Grad(0,-1,1),new Grad(0,1,-1),new Grad(0,-1,-1),];this.p=[...Array(256).keys()];this.perm=new Array(512);this.gradP=new Array(512);this.seed(seed)}
seed(seed){if(seed>0&&seed<1)seed*=65536;seed=Math.floor(seed);if(seed<256)seed|=seed<<8;for(let i=0;i<256;i++){let v=(i&1)?(this.p[i]^(seed&255)):(this.p[i]^((seed>>8)&255));this.perm[i]=this.perm[i+256]=v;this.gradP[i]=this.gradP[i+256]=this.grad3[v%12]}}
fade(t){return t*t*t*(t*(t*6-15)+10)}
lerp(a,b,t){return(1-t)*a+t*b}
perlin2(x,y){let X=Math.floor(x),Y=Math.floor(y);x-=X;y-=Y;X&=255;Y&=255;const n00=this.gradP[X+this.perm[Y]].dot2(x,y);const n01=this.gradP[X+this.perm[Y+1]].dot2(x,y-1);const n10=this.gradP[X+1+this.perm[Y]].dot2(x-1,y);const n11=this.gradP[X+1+this.perm[Y+1]].dot2(x-1,y-1);const u=this.fade(x);return this.lerp(this.lerp(n00,n10,u),this.lerp(n01,n11,u),this.fade(y))}};function Grad(x,y,z){this.x=x;this.y=y;this.z=z;this.dot2=function(x,y){return this.x*x+this.y*y}}
function dancepad_interactive_lines_v4(){InteractiveLinesV4.destroyAllInstances();document.querySelectorAll('.dan-interactive-lines-v4').forEach(container=>{const instance=new InteractiveLinesV4(container);InteractiveLinesV4.instances.push(instance)})}